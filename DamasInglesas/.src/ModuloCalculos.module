' Gambas module file

Public Function GenerateMoveList(tablero As Classboard, side As Integer) As ClassMoveListArray

  'NOTE: generando movimiento
  Dim mov As ClassMovimiento
  Dim movelist As New ClassMovelist 'contiene una lista de movimientos
  Dim movelistArray As New ClassMoveListArray 'contiene un array de listas de movimientos (lista de lista)
  Dim MastermovelistArray As New ClassMoveListArray 'contiene un array de listas de movimientos (lista de lista)
  Dim tempmovelistarray As New ClassMoveListArray
  Dim x As Integer
  Dim y As Integer
  Dim dx As Integer
  ' empieza pro ver si hay posibles saltos
  For x = 1 To 8
    For y = 1 To 8
      ' halla una pieza, entonces si puedo salto...
      If Sgn(tablero.tablero[x, y]) = side Then
        'empieza a añadir saltos legales estando en x,y
        movelistArray = FindAllJumps(tablero, x, y, side)
        'Añade  al array de listas de movimiento, la lista de movimiento.
        'FIXME: se incorpora los movimientos de saltos...
        If movelistArray <> Null Then
          MastermovelistArray.lista.Insert(movelistArray.lista)
        Endif
      Endif
    Next
  Next

  'Comprueba los otros movimientos
  If MastermovelistArray.lista.count = 0 Then
    For x = 1 To 8
      For y = 1 To 8
        If Sgn(tablero.tablero[x, y]) = side Then
          For dx = -1 To 1
            If dx = 0 Then Continue
            If validsinglemove(tablero, x, y, dx, side) Then
              mov = New ClassMovimiento(x, y, x + dx, y + side) 'es un mAdd
              If Not IsNull(movelist) Then
                movelist = New ClassMoveList
                movelist.movimiento.Add(mov)

              Else

                movelist.movimiento.Add(mov) 'añado a la lista de movimiento un movimiento
              Endif

              '  tempmovelistarray.lista.Add(movelist)
              MastermovelistArray.lista.Add(movelist) 'añado la lista de listas de movimiento

              ' mov = Null 'borro objeto
              '  movelist = Null 'borro objeto
            Endif
            If Abs(tablero.tablero[x, y]) = constantes.king Then
              If validsinglemove(tablero, x, y, dx, - side) Then
                mov = New ClassMovimiento(x, y, x + dx, y - side)
                If Not IsNull(movelist) Then
                  movelist = New ClassMoveList
                  movelist.movimiento.Add(mov)

                Else

                  movelist.movimiento.Add(mov) 'añado a la lista de movimiento un movimiento
                Endif
                MastermovelistArray.lista.Add(movelist) 'añado la lista de listas de movimiento

              Endif

            Endif
          Next
        Endif
      Next
    Next
  Endif

  Return MastermovelistArray

End

Public Function validsinglemove(tablero As Classboard, x As Integer, y As Integer, dx As Integer, dy As Integer) As Boolean
  'El movimeinto en diagonal es posible (no se sale del tablero)
  'y la celda esta vacia.

  If ((x + dx) >= 1) And ((x + dx) <= 8) And ((y + dy) >= 1) And ((y + dy) <= 8) Then
    If tablero.tablero[x + dx, y + dy] = Constantes.blank Then
      Return True
    Endif
  Endif
  Return False

End

Public Function findjumps(tablero As Classboard, x As Integer, y As Integer, side As Integer) As ClassMoveList

  Dim movimiento As ClassMovimiento
  Dim MoveList As New ClassMovelist
  Dim dx As Integer
  Dim anade As Integer

  anade = 0
  For dx = -1 To 1
    If dx = 0 Then Continue
    '' todas las piezas pueden saltar hacia delante...
    '' First, check that coordinates of destination square are legal
    If ((x + dx * 2) >= 1) And ((x + dx * 2) <= 8) And ((y + 2 * Side) >= 1) And ((y + 2 * Side) <= 8) Then
      '' Then, check if destination square is open and
      '' that intermediate square is enemy piece
      If (tablero.tablero[x + dx * 2, y + 2 * Side] = Constantes.Blank) And (Sgn(tablero.tablero[x + dx, y + side]) = - Side) Then
        'añado salto
        movimiento = New ClassMovimiento(x, y, x + dx, y + Side)
        MoveList.movimiento.add(movimiento)

        movimiento = New ClassMovimiento(x + dx, y + Side, x + dx * 2, y + Side * 2)
        MoveList.movimiento.add(movimiento)
        anade = 1
      Endif
    Endif

    '' solamente las Reinas pueden saltar hacia atras
    If Abs(tablero.tablero[x, y]) = Constantes.king Then
      If ((x + dx * 2) >= 1) And ((x + dx * 2) <= 8) And ((y - 2 * Side) >= 1) And ((y - 2 * Side) <= 8) Then
        'comprueba que  la celda de destina esta vacia
        'y que la intermedia es una pieza enemiga
        If (Tablero.tablero[x + dx * 2, y - 2 * Side] = Constantes.Blank) And (Sgn(tablero.tablero[x + dx, y - side]) = - Side) Then
          '' If we get here, we have a valid jump; add it
          '' to the movelist
          movimiento = New ClassMovimiento(x, y, x + dx, y - Side)
          MoveList.movimiento.Add(movimiento)

          movimiento = New ClassMovimiento(x + dx, y - Side, x + dx * 2, y - Side * 2)
          MoveList.movimiento.Add(movimiento)
          anade = 1
        Endif
      Endif
    Endif
  Next
  If anade = 1 Then
    Return movelist 'retorno los movimientos calculados
  Else
    Return Null
  Endif

End

Public Function FindAllJumps(board As Classboard, x As Integer, y As Integer, side As Integer) As ClassMoveListarray

  'NOTE: FindAllJumps, falta
  Dim a As Integer
  Dim b As Integer
  Dim movelist As New ClassMovimiento[]
  Dim movelistArray As New ClassMoveListArray
  Dim lista As New ClassMoveList
  Dim movimi As ClassMovimiento
  Dim board2 As Classboard
  Dim movelist2 As New ClassMovimiento[]
  Dim movelistArray2 As New ClassMoveListArray
  Dim movelist3 As New ClassMovimiento[]
  Dim counter As Integer
  Dim devuelve As ClassMoveList
  Dim repite As Integer = 0
  Dim borrarlinea As Boolean
  'Rellenar lista de movimientos con primer grado de saltos disponiblesevi
  'FIXME: revisar movimientos de findjumps
  '
  devuelve = findjumps(board, x, y, side)
  '  Print devuelve; " ";

  If devuelve <> Null Then movelistArray.lista.Add(devuelve)

  If devuelve <> Null And If movelistArray.lista.count <> 0 Then
    ' En cada salto, "hacer" el salto en un tablero temporal y
    ' Ver si  que conduce a nuevos saltos, si lo hace, entonces
    ' Tenemos que hacer una lista de nuevos saltos con el original
    ' Secuencia como una base y eliminar la secuencia de iniciación
    '  If constantes.prueba = "no" Then Goto finsaltos

    'para ver saltos multimpes
    For a = 1 To 8
      analizalistaparaverSaltos(ByRef movelistArray, board, side)
    Next

    Goto finsaltos

    counter = 0
    While (movelistArray.lista[counter].movimiento.count <> 0)

      If movelistArray.lista.count <> 0 Then
        movelist = movelistArray.lista[counter].movimiento

        board2 = MakeMove(board, movelistArray.lista[counter], False)
        movimi = movelist[movelist.max]

        movelistArray2.lista.add(findjumps(board2, movimi.x1, movimi.y1, side))

        For A = 0 To movelistArray2.lista.count - 1
          If Not (IsNull(movelistArray2.lista[a])) Then
            movelist3 = New ClassMovimiento[]
            movelist3 = movelist

            For b = 0 To movelistArray2.lista[a].movimiento.count - 1
              movelist3.Add(movelistArray2.lista[a].movimiento[b])

            Next

            lista.movimiento = movelist3

            movelistArray.lista.Add(lista)
            borrarlinea = True
          Endif

        Next
        ' Get rid of the current MoveList from MoveListArray
        ' Back counter by one because the initiating sequence
        ' was deleted

        If borrarlinea = True Then
          movelistArray.lista.Delete(counter)

        Endif

      Endif

      counter = counter + 1

      If counter > movelistArray.lista.max Then

        Break 'salimos del bucle
      Endif

    Wend

  Endif

finsaltos:

  If devuelve <> Null Then

    Return movelistArray ' movelistArray
  Endif

End

Public Sub determineMove(board As Classboard, site As Integer) As Classmovimiento[]

  'NOTE: Determinar Movimiento

End

Public Sub MakeMove(board As Classboard, movelist As Classmovelist, valor As Boolean) As Classboard

  Dim b As Integer
  Dim a As Integer
  'NOTE: MakeMove: hacer movimiento
  Dim pieza As Integer

  Dim boarModificado As New Classboard(8)

  For a = 0 To 8
    For b = 0 To 8
      boarModificado.tablero[a, b] = board.tablero[a, b]
    Next
  Next

  For a = 0 To movelist.movimiento.max

    pieza = boarModificado.tablero[movelist.movimiento[a].x0, movelist.movimiento[a].y0]
    boarModificado.tablero[movelist.movimiento[a].x0, movelist.movimiento[a].y0] = Constantes.blank

    boarModificado.tablero[movelist.movimiento[a].x1, movelist.movimiento[a].y1] = pieza

    If movelist.movimiento[a].y1 = 8 Or movelist.movimiento[a].y1 = 1 Then
      'se consique reina
      boarModificado.tablero[movelist.movimiento[a].x1, movelist.movimiento[a].y1] = constantes.king * Sgn(pieza)
    Endif

  Next

  Return boarModificado

End
'NOTE: MINIMAX Funcion...

Public Sub minimax(board As Classboard, side As Integer, Depth As Integer, DepthMax As Integer, Evaluator As Integer) As ClassRespuesta

  Dim a As Integer
  Dim solucion As ClassRespuesta
  Dim movimientoArray As New ClassMovimiento[]
  Dim movelistArray As New ClassMoveListArray
  Dim movimi As ClassMovimiento
  Dim score As Float
  Dim bestscore As Float
  Dim nextmini As ClassRespuesta
  Dim boardtemp As Classboard

  Dim bestmovelistArray As New ClassMovelistArray

  If Depth > depthmax Then
    'hemos accedido a la profundidad de busqueda, retorna el valor del tablero y lista nula de movimientos
    solucion = New ClassRespuesta(evaluateBoard(board, side, evaluator), Null)
    Return solucion
  Else
    movelistArray = GenerateMoveList(board, side)
    'TODO: Escribo los movimientos posibles...
    '  Print "Movimientos posibles...Turno "; side; " Profundidad: "; depth
    '    Print movelistArray.escribe()

    If movelistArray.lista.count = 0 Then
      'lista vacia
      solucion = New ClassRespuesta(evaluateBoard(board, side, evaluator), Null)
      Return solucion
    Else

      If JugadasInicialesIguales(movelistArray.lista).valor = 0 Then
        'FIXME: Jugadas Iniciales

        boardtemp = MakeMove(board, movelistArray.lista[0], side)
        solucion = New ClassRespuesta(evaluateBoard(boardtemp, side, evaluator), movelistArray.lista[0].movimiento)
        Return solucion

      Else

        'hallar el mejor movimiento....
        '
        bestscore = -999999
        For a = 0 To movelistArray.lista.Max

          nextmini = minimax(MakeMove(board, movelistArray.lista[a], False), - side, depth + 1, depthmax, evaluator)
          score = - nextmini.valor

          If score >= bestscore Then
            If score = bestscore Then
              'la añado a la lista de mejores...

              bestmovelistArray.lista.Add(movelistArray.lista[a])

            Else

              bestscore = score
              bestmovelistArray.lista.Clear()
              bestmovelistArray.lista.add(movelistArray.lista[a], 0)

            Endif

          Endif

        Next
        movimientoArray = bestmovelistArray.lista[Int(Rnd(0, bestmovelistArray.lista.count))].movimiento
        '   Print "Solucion mejor: ";
        ' For a = 0 To movimientoArray.Max
        '   Print movimientoArray[a].escribe()
        ' Next
        solucion = New ClassRespuesta(bestscore, movimientoArray)
      Endif
    Endif
  Endif
  Return solucion

End
''-----------------------------------------------
''         Funcion Evaluador de tableros...
''-----------------------------------------------

Public Function evaluateBoard(tablero As Classboard, side As Integer, evaluator As Integer) As Float

  Select Evaluator
    Case 1
      Return scoreS(tablero, side) 'solo cuenta piezas
    Case 2
      Return scoreSimple(tablero, side) 'cuenta piezas y reinas al centro.
    Case 3
      Return scoreNat(tablero, side)
    Case 4
      Return scoreSam(tablero, side)

  End Select

End

''**************************************************
'' Funciones de valoracion...
''**************************************************
'funcion simple para retornar valor de las piezas en el tablero
Public Function scoreS(tablero As Classboard, side As Integer) As Float

  Dim x As Integer
  Dim y As Integer
  Dim score As Float
  Dim pieza As Integer
  Dim dist As Float
  '¿puedo mover? No--> he perdido, dar la minima puntuacion
  '¿tengo piezas? No--> he perdido, dar la minima puntuacion

  If comprobarfin(tablero, side) = True Then
    score = -99999 * side
    Return score
  Endif
  'valoracion de piezas
  For x = 1 To 8
    For y = 1 To 8

      pieza = tablero.tablero[x, y]
      If pieza = 0 Then Continue
      score += pieza * 100

    Next
  Next

  score *= side

  Return score

End

Public Function scoresimple(tablero As Classboard, side As Integer) As Float

  Dim x As Integer
  Dim y As Integer
  Dim score As Float
  Dim pieza As Integer
  Dim dist As Float
  '¿puedo mover? No--> he perdido, dar la minima puntuacion
  '¿tengo piezas? No--> he perdido, dar la minima puntuacion

  If comprobarfin(tablero, side) = True Then
    score = -99999 * side

    Return score
  Endif
  'valoracion de piezas
  For x = 1 To 8
    For y = 1 To 8
      pieza = tablero.tablero[x, y]
      If pieza = 0 Then Continue
      score += pieza * 100
      'valoracion de posicion reinas
      If Sgn(pieza) = Constantes.king Then
        dist = (Abs(4.5 - x) / 4.5 + Abs(4.5 - y) / 4.5) * pieza
        score += dist
      Else
        If pieza = -1 Then  'negra
          'FIXMe: pieza -1
          score += Sgn(8 - x) / 8 * 2
          score += Sgn(4 - y) / 4
        Else
          If pieza = 1 Then
            'blancas, cuantos mas cerca de las filas 1, y centrales mejor
            score += (x) * 2 / 8
            score += Sgn(4 - y) / 4
          Endif
        Endif

      Endif

    Next
  Next

  score *= side

  Return score

End

'funcion que añade bonux por canales de cuadrados
'y piezas avanzadas...

Public Function scorenat(tablero As Classboard, side As Integer) As Float

  Dim pieza As Integer
  Dim x As Integer
  Dim y As Integer
  Dim score As Float
  '¿puedo mover? No--> he perdido, dar la minima puntuacion
  '¿tengo piezas? No--> he perdido, dar la minima puntuacion
  If comprobarfin(tablero, side) = True Then
    score = -99999 * side
  Endif

  For x = 1 To 8
    For y = 1 To 8
      pieza = tablero.tablero[x, y]
      If pieza = 0 Then Continue
      score += pieza
      If x = 1 Or x = 8 Then
        score += 0.5 * pieza
      Endif

      'bonus por abance al final
      If Abs(pieza) = constantes.piece Then
        If side = 1 Then
          score += 0.125 * y
        Else
          score += -0.125 * (8 + 1 - y)

        Endif
      Endif

    Next
  Next
  score *= side

  Return score

End

Public Function scoreSam(tablero As Classboard, side As Integer) As Float

  Dim pieza As Integer
  Dim x As Integer
  Dim y As Integer
  Dim score As Float
  '¿puedo mover? No--> he perdido, dar la minima puntuacion
  '¿tengo piezas? No--> he perdido, dar la minima puntuacion
  If comprobarfin(tablero, side) = True Then
    score = -99999 * side
    Return score
  Endif

  For x = 1 To 8
    For y = 1 To 8
      pieza = tablero.tablero[x, y]
      score += pieza
      If pieza = 0 Then Continue
      If (x = 1) Or (x = 8) Then
        score += -0.5 * pieza
      Endif

      If ((x = 1) Or (x = 8)) And (y = 1 Or y = 8) Then
        score += -0.5 * pieza
      Endif

    Next
  Next

  score *= side

  Return score

End

Public Sub analizalistaparaverSaltos(ByRef movelistArray As ClassMoveListArray, board As Classboard, side As Integer)

  Dim counter As Integer
  Dim a As Integer
  Dim b As Integer
  Dim movelistArray2 As New ClassMoveListArray
  Dim board2 As Classboard
  Dim movimi As ClassMovimiento
  Dim movelist As ClassMovimiento[]
  Dim movelist3 As New ClassMovimiento[]
  Dim borrarlinea As Boolean
  Dim lista As New ClassMoveList

  counter = 0
  While (movelistArray.lista[counter].movimiento.count <> 0)

    If movelistArray.lista.count <> 0 Then
      movelist = movelistArray.lista[counter].movimiento

      board2 = MakeMove(board, movelistArray.lista[counter], False)
      movimi = movelist[movelist.max]

      movelistArray2.lista.add(findjumps(board2, movimi.x1, movimi.y1, side))

      For A = 0 To movelistArray2.lista.count - 1
        If Not (IsNull(movelistArray2.lista[a])) Then
          movelist3 = New ClassMovimiento[]
          movelist3 = movelist

          For b = 0 To movelistArray2.lista[a].movimiento.count - 1
            movelist3.Add(movelistArray2.lista[a].movimiento[b])

          Next

          lista.movimiento = movelist3

          movelistArray.lista.Add(lista)
          borrarlinea = True
        Endif

      Next
      ' Get rid of the current MoveList from MoveListArray
      ' Back counter by one because the initiating sequence
      ' was deleted

      If borrarlinea = True Then
        movelistArray.lista.Delete(counter)

      Endif

    Endif

    counter = counter + 1

    If counter > movelistArray.lista.max Then

      Break 'salimos del bucle
    Endif

  Wend

End

Public Function comprobarfin(tablero As Classboard, side As Integer) As Boolean

  Dim listamovArray As ClassMoveListArray
  '¿tengo piezas? No--> he perdido, dar la minima puntuacion
  If tablero.piezasDisponibles(side) = 0 Then Return True

  '¿puedo mover? No--> he perdido, dar la minima puntuacion

  listamovArray = ModuloCalculos.GenerateMoveList(tablero, side)
  If listamovArray.lista.count = 0 Then Return True

End

'Comprobar que las jugadas iniciales son iguales
Public Sub JugadasInicialesIguales(lista As ClassMoveList[]) As ClassRespuesta

  Dim a As Integer
  Dim movimiento As New ClassMovimiento(0, 0, 0, 0)
  Dim sol As ClassRespuesta

  movimiento = lista[0].movimiento[0]
  sol = New ClassRespuesta(0, lista[0].movimiento)

  If lista.max = 0 Then Return sol

  For a = 1 To lista.Max
    If lista[a].movimiento[0] <> movimiento Then
      'he encontrado jugadas distintas
      sol.valor = 1
      Return sol
    Endif
  Next

  Return sol

End
